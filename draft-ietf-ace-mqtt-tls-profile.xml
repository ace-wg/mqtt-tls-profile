<?xml version="1.0" encoding="US-ASCII"?>
<!-- This template is for creating an Internet Draft using xml2rfc,
    which is available here: http://xml.resource.org. -->
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
        <!-- One method to get references from the online citation libraries.
            There has to be one entity for each item to be referenced.
            An alternate method (rfc include) is described in the references. -->
	<!ENTITY RFC8174 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.8174.xml">
    <!ENTITY RFC2119 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml">
    <!ENTITY RFC2629 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2629.xml">
    <!ENTITY RFC4648 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4648.xml">
    <!ENTITY RFC4949 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4949.xml">
    <!ENTITY RFC6749 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.6749.xml">
    <!ENTITY RFC7800 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.7800.xml">
    <!ENTITY RFC7250 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.7250.xml">
	]>
<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>
<!-- used by XSLT processors -->
<!-- For a complete list and description of processing instructions (PIs),
    please see http://xml.resource.org/authoring/README.html. -->
<!-- Below are generally applicable Processing Instructions (PIs) that most I-Ds might want to use.
    (Here they are set differently than their defaults in xml2rfc v1.32) -->
<?rfc strict="yes" ?>
<!-- give errors regarding ID-nits and DTD validation -->
<!-- control the table of contents (ToC) -->
<?rfc toc="yes"?>
<!-- generate a ToC -->
<?rfc tocdepth="4"?>
<!-- the number of levels of subsections in ToC. default: 3 -->
<!-- control references -->
<?rfc symrefs="yes"?>
<!-- use symbolic references tags, i.e, [RFC2119] instead of [1] -->
<?rfc sortrefs="yes" ?>
<!-- sort the reference entries alphabetically -->
<!-- control vertical white space
    (using these PIs as follows is recommended by the RFC Editor) -->
<?rfc compact="yes" ?>
<!-- do not start each main section on a new page -->
<?rfc subcompact="no" ?>
<!-- keep one blank line between list items -->
<!-- end of list of popular I-D processing instructions -->
<rfc category="std" docName="draft-ietf-ace-mqtt-tls-profile-01" ipr="trust200902">
    <!-- category values: std, bcp, info, exp, and historic
       ipr values: trust200902, noModificationTrust200902, noDerivativesTrust200902,
          or pre5378Trust200902
       you can add the attributes updates="NNNN" and obsoletes="NNNN"
       they will automatically be output with "(if approved)" -->

    <!-- ***** FRONT MATTER ***** -->
    <front>
        <!-- The abbreviated title is used in the page header - it is only necessary if the
             full title is longer than 39 characters -->

        <title abbrev="MQTT-TLS profile of ACE">MQTT-TLS profile of ACE</title>

        <!-- add 'role="editor"' below for the editors if appropriate -->

        <!-- Author 1-->

        <author fullname="Cigdem Sengul" initials="C.S."
                surname="Sengul">
            <organization>Nominet</organization>
            <address>
                <postal>
                    <street>4 Kingdom Street</street>
                    <!-- Reorder these if your country does things differently -->
                    <city>London</city>
                    <code>W2 6BD</code>
                    <country>UK</country>
                </postal>
                <email>Cigdem.Sengul@nominet.uk</email>
                <!-- uri and facsimile elements may also be added -->
            </address>
        </author>

        <!-- Author 2-->

        <author fullname="Anthony Kirby" initials="A.K"
                surname="Kirby">
            <organization>Oxbotica</organization>
            <address>
                <postal>
                    <street>1a Milford House, Mayfield Road, Summertown</street>
                    <!-- Reorder these if your country does things differently -->
                    <city>Oxford</city>
                    <code>OX2 7EL</code>
                    <country>UK</country>
                </postal>
                <email>anthony@anthony.org</email>
            </address>
        </author>

	    <!-- Author 3 -->
	    <author fullname="Paul Fremantle" initials="P.F"
		    surname="Fremantle">
	        <organization>University of Portsmouth</organization>
	        <address>
	            <postal>
	                <street>School of Computing, Buckingham House</street>
	                <city>Portsmouth</city>
	                <code>PO1 3HE</code>
	                <country>UK</country>
	            </postal>
	            <email>paul.fremantle@port.ac.uk</email>
	        </address>
	    </author>
    <date year="2019"/>
        <!-- If the month and year are both specified and are the current ones, xml2rfc will fill
             in the current day for you. If only the current year is specified, xml2rfc will fill
          in the current day and month for you. If the year is not the current one, it is
          necessary to specify at least a month (xml2rfc assumes day="1" if not specified for the
          purpose of calculating the expiry date).  With drafts it is normally sufficient to
          specify just the year. -->
        <!-- Meta-data Declarations -->
        <area>Security</area>
        <workgroup>ACE Working Group</workgroup>

        <!-- WG name at the upperleft corner of the doc,
             IETF is fine for individual submissions.
          If this element is not present, the default is "Network Working Group",
             which is used by the RFC Editor as a nod to the history of the IETF. -->
        <keyword>Internet-Draft</keyword>
        <!-- Keywords will be incorporated into HTML output
             files in a meta tag but they have no effect on text or nroff
             output. If you submit your draft to the RFC Editor, the
             keywords will be used for the search engine. -->

        <abstract>
            <t>
                This document specifies a profile for the ACE (Authentication and Authorization for Constrained
                Environments) to enable authorization in an MQTT-based publish-subscribe messaging system.
                Proof-of-possession keys, bound to OAuth2.0 access tokens, are used to authenticate and authorize
                MQTT Clients. The protocol relies on TLS for confidentiality and server authentication.
            </t>
        </abstract>
    </front>

    <middle>
        <section title="Introduction">
            <t>
                This document specifies a profile for the ACE framework <xref target="I-D.ietf-ace-oauth-authz"></xref>.
                In this profile, Clients and a Broker use MQTT to exchange Application messages.
                The protocol relies on TLS for
                communication security between entities. The MQTT protocol interactions
                 are described based on the <xref target="MQTT-OASIS-Standard-v5">MQTT v5.0 - the OASIS Standard</xref>.
                 It is expected that MQTT deployments will retain
                backward compatibility for MQTT v3.1.1 clients, and therefore,
		        this document describes a reduced set of protocol interactions suited
                 to <xref target="MQTT-OASIS-Standard">MQTT v3.1.1 - the OASIS Standard</xref>.
		        However, it is RECOMMENDED to use MQTT v5.0 as it works more naturally
                 with ACE-style authentication and authorization.
            </t>
            <t>
                MQTT is a publish-subscribe protocol and supports two main types of Client operation:
                publish and subscribe. Once connected, a Client can publish to multiple topics,
                and subscribe to multiple topics.
                The MQTT Broker is responsible for distributing messages published by the publishers
                 to the appropriate subscribers. Each publish message contains a Topic Name,
                 which is used by the Broker to filter the subscribers for the message.
                Subscribers must subscribe to the topics to receive the corresponding messages.
            </t>
            <t>
                In this document, message topics are treated as resources.
                Clients use an access token, bound to a key (the proof-of-possession key) to authorize
                with the MQTT Broker their connection and publish/subscribe permissions to topics. In the context
                of this ACE profile, the MQTT Broker acts as the Resource Server (RS). In the rest of the
                 document RS and Broker are used interchangeably.
                To provide communication confidentiality and Resource Server authentication, TLS is used,
                and TLS 1.3 is RECOMMENDED.
                This document makes the same assumptions as the Section 4 of
		        <xref target="I-D.ietf-ace-oauth-authz"> the
                ACE framework</xref> regarding Client and RS registration with the Authorization Server (AS) and setting up keying material.
            </t>
            <t>This document describes the authorization of the following exchanges between
                Clients and the Broker.
                <list style="symbols">
                    <t>Connection establishment between the Clients and the Broker</t>
                    <t>Publish messages from the Clients to the Broker, and from the Broker to the Clients</t>
                    <t>Subscribe messages from the Clients to the Broker</t>
                </list>
                While the Client-Broker exchanges are only over MQTT, the required Client-AS and RS-AS interactions are
                described for HTTPS-based communication, using 'application/ace+json' content type, and unless otherwise
                specified, using JSON encoding. The token may be a reference, or JWT.
                For JWT tokens, this document follows <xref target="RFC7800">RFC 7800</xref>
                for PoP semantics for JWTs. The Client-AS and RS-AS may also be based on CoAP. It is also possible to use
                'application/ace+cbor' content type, and CBOR encoding, and CWT and associated PoP semantics to reduce the protocol memory and bandwidth
                requirements.  For more information on Proof of Possession semantics for CWTs,
			    see <xref target="I-D.ietf-ace-cwt-proof-of-possession">Proof-of-Possession Key
                Semantics for CBOR Web Tokens (CWTs)</xref>.
            </t>

            <section title="Requirements Language">
                <t>
                    The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
                    "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED",  "MAY", and "OPTIONAL" in this
                    document are to be interpreted as described in BCP 14 <xref target="RFC2119"></xref> <xref target="RFC8174"></xref>,
                     when, and only when, they appear in all capitals, as shown here.
                </t>
            </section>

            <section title="ACE-Related Terminology">
                <t>
                    The terminology for entities in the architecture is defined in OAuth 2.0 <xref target="RFC6749">RFC
                    6749 </xref> such as "Client" (C),
                     "Resource Server" (RS) and "Authorization Server" (AS).
                </t>
                <t>
                    The term "endpoint" is used following its OAuth definition, to denote resources such as /token and
                    /introspect at the AS.
                </t>
                <t>
                    The term "Resource" is used to refer to an MQTT Topic Name, which is defined in <xref target="mqtt-defs"></xref>.
                    Hence, the "Resource Owner" is any entity that can authoritatively speak for the topic.
                </t>
                <t>
                    Certain security-related terms such as "authentication", "authorization", "confidentiality", "(data)
                    integrity",
                    "message authentication code", and "verify" are taken from  <xref target="RFC4949">RFC 4949</xref>.
                </t>
            </section>

            <section title="MQTT-Related Terminology" anchor="mqtt-defs">
                <t>
                    The document describes message exchanges as MQTT protocol interactions. The Clients are MQTT Clients,
                    which connect to the Broker to publish and subscribe to Application Messages. For additional information,
                    please refer to the <xref target="MQTT-OASIS-Standard-v5">MQTT v5.0
                     - the OASIS Standard</xref> or the <xref target="MQTT-OASIS-Standard">MQTT v3.1.1
                      - the OASIS Standard</xref>.
                </t>
                <t>
                    <list hangIndent="8" style="hanging">
                        <t hangText="MQTTS">
                            <vspace blankLines="0"/>
                            Secured transport profile of MQTT.  MQTTS runs over TLS.
                        </t>
                        <t hangText="Broker">
                            <vspace blankLines="0"/>
                            The Server in MQTT. It acts as an intermediary between Clients that publishes Application Messages,
                            and the Clients that made Subscriptions. The Broker acts as the Resource Server for the Clients.
                        </t>
                        <t hangText="Application Message">
                            <vspace blankLines="0"/>
                            The data carried by the MQTT protocol. The data has an associated QoS level and a Topic
                            Name.
                        </t>
                        <t hangText="QoS level">
                            <vspace blankLines="0"/>
                            The level of assurance for the delivery of an Application Message. The QoS level can be 0-2,
                            where "0" indicates "At most once delivery", "1" "At least once delivery", and "2" "Exactly once delivery".
                        </t>
                        <t hangText="Topic Name">
                            <vspace blankLines="0"/>
                            The label attached to an Application Message, which is matched to a Subscription.
                        </t>
                        <t hangText="Subscription">
                            <vspace blankLines="0"/>
                            A subscription comprises a Topic Filter and a maximum Quality of Service (QoS).
                        </t>
                        <t hangText="Topic Filter">
                            <vspace blankLines="0"/>
                            An expression that indicates interest in one or more Topic Names. Topic Filters may include
                            wildcards.
                        </t>
                    </list>
                </t>
                <t>
                    MQTT sends various control messages across a network connection.
                    The following is not an exhaustive list and the control packets that are not relevant for
                    authorization are not explained.
                    These include, for instance, the PUBREL and PUBCOMP packets used in the 4-step handshake required
                    for the QoS level 2.
                    <list hangIndent="8" style="hanging">
                        <t hangText="CONNECT">
                            <vspace blankLines="0"/>
                            Client request to connect to the Broker. After a network connection is established, this is
                            the first packet sent by a Client.
                        </t>
                        <t hangText="CONNACK">
                            <vspace blankLines="0"/>
                            The Broker connection acknowledgment. The first packet sent from the Broker to a Client is a
                            CONNACK packet. CONNACK packets
                            contain return codes indicating either a success or an error state to a Client.
                        </t>
                        <t hangText="PUBLISH">
                            <vspace blankLines="0"/>
                            Publish packet that can be sent from a Client to the Broker, or from the Broker to a
                            Client.
                        </t>
                        <t hangText="PUBACK">
                            <vspace blankLines="0"/>
                            Response to PUBLISH packet with QoS level 1. PUBACK can be sent from the Broker to a
                            Client or a Client to the Broker.
                        </t>
                        <t hangText="PUBREC">
                            <vspace blankLines="0"/>
                            Response to PUBLISH packet with QoS level 2. PUBREC can be sent from the Broker to a
                            Client or a Client to the Broker.
                        </t>
                        <t hangText="SUBSCRIBE">
                            <vspace blankLines="0"/>
                            The Client subscribe request.
                        </t>
                        <t hangText="SUBACK">
                            <vspace blankLines="0"/>
                            Subscribe acknowledgment.
                        </t>
			            <t hangText="PINGREQ">
                            <vspace blankLines="0"/>
			                A ping request sent from a Client to the Broker.  It signals to the Broker that the Client is alive, and
			                 is used to confirm that the Broker is still alive. The "Keep Alive" period is set in the CONNECT message.
			            </t>
                        <t hangText="PINGRESP">
                            <vspace blankLines="0"/>
			                Response sent by the Broker to the Client in response to PINGREQ. It indicates the Broker is alive.
			            </t>
                        <t hangText="Will">
                            <vspace blankLines="0"/>
                            If the network connection is not closed normally, the Server sends a last Will message
                            for the Client, if the Client provided one in its CONNECT message.
                            If the Will Flag is set, then the payload of the CONNECT message includes information
                            about the Will. The information consists of the Will Properties, Will Topic,
                            and Will Payload fields.
			            </t>
                    </list>
                </t>
            </section>
        </section>
        <section title="Protocol Interactions" anchor="protocol-interactions">
            <t>
                This section describes the following exchanges between Clients, the Broker, and
	            the Authorization Server according to the MQTT v5.0.
                <list style="symbols">
                    <t>Authorizing connection requests from the Clients to the Broker</t>
                    <t>Authorizing publish messages from the Clients to the Broker, and from the Broker to the
                        Clients</t>
                    <t>Authorizing subscribe messages from Clients to the Broker</t>
                </list>
                <xref target="MQTTv311"></xref>
	            describes how these exchanges can also be supported using the
	            MQTT v3.1.1.  MQTT v5.0 brokers MAY also only support the basic operation; however, this is NOT RECOMMENDED.
            </t>
            <t>
                In this profile document, message topics are treated as resources.
                The Clients are assumed to have identified the publish/subscribe topics of interest out-of-band
                (topic discovery is not a feature of the MQTT protocol).
                A resource owner can pre-configure policies at the AS that give Clients publish or subscribe
                permissions to different topics.
            </t>
            <section title="Authorizing Connection Requests" anchor="token_acquisition">
                <t>
                    This section specifies how Client connections can be authorized by an MQTT
                    Broker.  <xref target="protocol_flow"></xref> shows the basic protocol flow during connection
                    set-up.The token request and response
                    use the /token endpoint of the authorization server, specified in the Section 5.6 of the <xref
                    target="I-D.ietf-ace-oauth-authz">ACE framework</xref>. Steps (D) and (E) are optional,
                    and use the introspection endpoint, specified in the Section 5.7 of the ACE framework.
                    The Client and Broker use HTTPS to communicate to AS via these endpoints.
                    The Client and Broker only use MQTT to communicate between them.
                </t>
                <t>
                    If the Client is resource-constrained, a Client Authorisation Server may carry out
                    the token request on behalf of the Client, and later, onboard the Client with the token.
                     Also, the C-AS and Broker-AS interfaces may be implemented using protocols other than HTTPS, e.g., CoAP or MQTT.
                    The interactions between a Client and its Client Authorization Server for token
                    onboarding, and the
                    MQTTS support for token requests are out of scope of this document.
                </t>
                <figure align="center" anchor="protocol_flow" title="Connection set-up">
                    <artwork align="left"><![CDATA[
                          +---------------------+
                          | Client              |
                          |                     |
   +---(A) Token request--| Client -            |
   |                      | Authorization       |
   |   +-(B) Access token-> Server Interface    |
   |   |                  |       (HTTPS)       |
   |   |                  |_____________________|
   |   |                  |                     |
+--v-------------+        |  Pub/Sub Interface  |
|  Authorization |        |     (MQTTS)         |
|  Server        |        +-----------^---------+
|________________|            |       |
   |    ^             (C)Connection  (F)Connection
   |    |               request +    response
   |    |               access token  |
   |    |                     |       |
   |    |                 +---v--------------+
   |    |                 |   Broker (MQTTS) |
   |    |                 |__________________|
   |    +(D)Introspection-|                  |
   |   request (optional) | RS-AS interface  |
   |                      |     (HTTPS)      |
   +-(E)Introspection---->|__________________|
     response (optional)
           ]]></artwork>
                </figure>

                <section title="Client Token Request to the Authorization Server (AS)">
                    <t>
                        The first step in the protocol flow (Figure 1 (A)) is the token acquisition by the Client from the AS.
                        When requesting an access token from the AS, the Client follows the token request as is
                        described in Section 5.6.1
                        of <xref target="I-D.ietf-ace-oauth-authz">the ACE framework</xref>, howevever, it MUST
                        set the profile parameter to 'mqtt_tls'.
                        The media format is 'application/ace+json'.
                        The OAuth 2.0 AS uses a JSON structure in the payload of its responses both to client and RS.
                    </t>
                    <t>
                        If the AS successfully verifies the access token request and authorizes the Client for the
                        indicated audience (e.g., RS) and scopes (e.g., publish/subscribe permissions over topics),
                        the AS issues an access token (Figure 1 (B)).
                        The response includes the parameters described in Section 5.6.2 of <xref
                            target="I-D.ietf-ace-oauth-authz">the ACE framework</xref>.
                        The included token is assumed to be Proof-of-Possession (PoP) token by default.
                        This document follows <xref target="RFC7800">RFC 7800</xref> for PoP semantics for JWTs.
                        The PoP token includes a 'cnf' parameter with a symmetric or asymmetric PoP key.
                          Note that the 'cnf' parameter in the web tokens
                        are to be consumed by the resource server and not the Client.
                    </t>
                    <t>
                        In the case of an error, the AS returns error responses for
                         HTTP-based interactions as ASCII
                        codes in JSON content, as defined in Section 5.2 of <xref target="RFC6749">RFC 6749</xref>.
                    </t>
                </section>
                <section title="Client Connection Request to the Broker (C)" anchor="connect_v5">
		            <t>
                        This section describes how the Client transports the token to the Broker
                        (RS) via the CONNECT control message after the TLS handshake.
                        This is similar to an earlier proposal by Fremantle et al.
                        <xref target="fremantle14"></xref>. Alternatively, the token may be used
                        for the TLS session set-up as described in
                        the <xref target="I-D.gerdes-ace-dtls-authorize">DTLS profile for ACE</xref>.
                         In this case, both the TLS PSK and RPK handshakes MAY be supported.
                        This may additionally require that the Client transports the token to the Broker
                         before requesting to an authorized connection.
                        To this end, the Broker MAY support /authz-info endpoint via the "authz-info" topic.
			            Then, to transport the token, Clients publish to "authz-info" topic unauthorized.
                        The topic "authz-info" MUST be publish-only for Clients (i.e.,
                        the Clients are not allowed to subscribe to it).
                        This option is described in more detail in
                        <xref target="app-authzinfo"></xref>.
		            </t>
		            <t>
		                After the token acquisition, the Client connects to the RS (Broker)
                         using the CONNECT message of MQTT over TLS. For server authentication,
                         the client MAY either have the ability to receive and validate a certificate
                        or a raw public key from the Broker. The client needs to use
                        this raw public key in the TLS handshake together
                        with an out-of-band validation technique (see <xref target="RFC7250">RFC 7250</xref>
                        for details).
                    </t>
                    <t>
		                <xref target="mqtt5_connect_message"></xref> shows the structure of the
                         MQTT CONNECT control message used in MQTT v5.0.  A CONNECT message is composed of a fixed header, a variable header and a payload.
                         The fixed header contains Control Packet Type (CPT), Reserved, and Remaining Length.
                         The Variable Header contains the Protocol Name, Protocol Level, Connect Flags, Keep Alive, and Properties.
                        The Connect Flags in the variable header specify the behavior of the MQTT connection.
                         It also indicates the presence or absence of fields in the Payload.
                        The payload contains one or more encoded fields, namely a unique Client
                         identifier for the Client, a Will Topic, Will Payload, User Name and Password.
                          All but the Client identifier can be omitted depending on flags in the Variable Header.
		            </t>
		  <figure align="center" anchor="mqtt5_connect_message"
                            title="MQTT v5 CONNECT control message with ACE authentication method. (CPT=Control Packet Type)">
		    <artwork align="left"><![CDATA[
       0            8            16            24            32
       +------------------------------------------------------+
       |CPT=1 | Rsvd.|Remaining len.| Protocol  name len. = 4 |
       +------------------------------------------------------+
       |                      'M' 'Q' 'T' 'T'                 |
       +------------------------------------------------------+
       | Proto.level=5|Connect flags|          Keep alive     |
       +------------------------------------------------------+
       |                 Property length                      |
       |          Auth. Method (0x15) | 'ace'                 |
       |          Auth. Data (0x16)   | empty or token or     |
       |                                token + PoP data      |
       +------------------------------------------------------+
       |                     Payload                          |
       +------------------------------------------------------+
        ]]></artwork>
            </figure>
                    <t>
                        Connect Flags include Clean Start, Will, Will QoS, Will Retain, Password and Username flags.
                        <xref target="mqtt_connect_flags"></xref> shows how the MQTT connect
                        flags MUST be set to initiate a connection with the Broker.
                    </t>
                    <figure align="center" anchor="mqttv5_connect_flags" title="MQTT CONNECT flags. (Rsvd=Reserved)">
                    <artwork align="left"><![CDATA[
+-----------------------------------------------------------+
|User name|Pass.|Will retain|Will QoS|Will Flag|Clean| Rsvd.|
| flag    |flag |           |        |         |     |      |
+-----------------------------------------------------------+
| 0       | 0   |    X      |   X X  |   X     |  1   |  0  |
+-----------------------------------------------------------+
         ]]></artwork>
         </figure>
                    <t>
                        To achieve a clean session (i.e., the session starts without an existing session),
	                    the Clean Start Flag MUST be set to 1. In addition, if the Session Expiry Interval is present in the CONNECT
                        message, it MUST be set to 0.
	                </t>
	                <t>
                        The Will Flag indicates that a Will message needs to be sent if network connection is
                        not closed normally.
                        The situations in which the Will message
                        is published include disconnections due to I/O or network failures,
                         and the server closing the network connection due to a protocol error.
                        The Client may set the Will Flag as desired (marked as 'X' in <xref target="mqttv5_connect_flags"></xref>).
                        If the Will Flag is set to 1 and the Broker accepts the connection request, the Broker must
                        store the Will message, and  publish it when the network connection is closed according to Will QoS and
	                    Will retain parameters, and MQTT Will management rules.  To avoid publishing Will Messages
                         in the case of temporary network disconnections,
                        the Client my specify a Will Delay Interval in Will Properties.
                        <xref target="disconnections"></xref> explains how the Broker deals with the retained messages in further detail.
                    </t>
	                <t>
	                    For token transport, the RS SHOULD support AUTH (Authentication Exchange) method.
                         The RS MAY support
	                    token transport via username and password, which is described in  <xref target="MQTTv311"></xref> for MQTT v3.1.1.
	                    The rest of this section describes the AUTH method, for which the username and password flags MUST be set to 0.
                    </t>
                    <t>
                        To implement the AUTH (Authentication Exchange) method, the Client MUST
                         set the Authentication Method as a property of a CONNECT packet by
                        using the property identifier 21 (0x15).
                        This is followed by a UTF-8 Encoded String containing the name of the
                         authentication method, which MUST be set to 'ace'. If the RS does not support this profile,
                         it sends a CONNACK with a Reason Code of '0x8C (Bad authentication method)'.
	                </t>
                    <t>
                        The Authentication Method is followed by the Authentication Data,
                         which has a property identifier 22 (0x16) and is binary data.
                         Based on the Authentication Data, this profile allows:
                        <list style="symbols">
                            <t>Proof-of-Possession over predefined field</t>
                            <t>Proof-of-Possession via challenge/response</t>
                            <t>Unauthorised request: Authorisation Server discovery</t>
                        </list>
                    </t>
                    <section title="Proof-of-Possession over Predefined Field" anchor="pop_payload">
	                    <t>
                            For this option, the Authentication Data MUST contain the token
                            and the keyed message digest (MAC) or the Client signature.
                             To calculate the keyed message digest (MAC) or the Client signature,
                             the Client SHOULD apply the PoP key to the CONNECT payload.
                            The CONNECT payload has at least a Client Identifier, and if the Will Flag is set to 1,
                              may contain Will-related information. The Client Identifier is a MUST be a UTF-8 Encoded String
                              (i.e., is prefixed with a two-byte integer length field that gives the number of
                            bytes in a UTF-8 encoded string itself). The Client Identifier may be 1-23 UTF-8 encoded bytes,
                            and contain only the characters "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ".
                            However, according to MQTTv5 standard, the Broker may except longer Client Identifiers,
                            and characters not included in the list given above.
                            Clients MUST change their Client Identifier for each session,
                            if the Client Identifier is the only source of randomness
                            in the payload to defend against a replay attack. If the Client reuses its Client
                            Identifier across different sessions, the Authentication Data MUST also contain a nonce, and
                            the keyed message digest (MAC) or the Client signature MUST be computed over this nonce.
                            Finally, the token is validated as described in  <xref target="token_validation"></xref>
                            and the server responds with a CONNACK.
	                    </t>
                    </section>
                    <section title="Proof-of-Possession via challenge/response" anchor="pop_challenge">
	                    <t>
	                        For this option, the RS follows a challenge/response protocol.
                            The success case is illustrated in <xref target="pop_challenge_response"></xref>.
                            If the Authentication Data only includes the token,
                            the RS MUST respond with an AUTH packet,
                            with the Authenticate Reason Code set to '0x18 (Continue Authentication)'.
                            This packet includes the Authentication Method, which MUST be set to 'ace'
                             and Authentication Data. The Authentication Data MUST NOT be empty and contains
                             a challenge for the Client. The Client responds to this with an AUTH packet
                              with a reason code '0x18 (Continue Authentication)'.
                            Similarly, the Client packet sets the Authentication Method to 'ace'.
                            The Authentication Data in the Client's response contains
                            the signature or MAC computed over the RS's challenge. Next,
                            the token is validated as described in  <xref target="token_validation"></xref>.
	                    </t>
                         <figure align="center" anchor="pop_challenge_response" title="PoP Challenge/Response Protocol Flow - Success">
                    <artwork align="left"><![CDATA[
                                Resource
                    Client      Server
                     |             |
                     |<===========>| TLS connection set-up
                     |             |
                     |             |
                     +------------>| CONNECT with Authentication Data
                     |             | contains only token
                     |             |
                     <-------------+ AUTH '0x18 (Continue Authentication)'
                     |             | challenge
                     |             |
                     |------------>| AUTH '0x18 (Continue Authentication)'
                     |             | signature
                     |             |
                     |             |-----+ Token validation (may involve introspection)
                     |             |     |
                     |             |<----+
                     |             |
                     |<------------+ CONNACK '0x00 (Success)'
                     ]]></artwork>
                    </figure>
                    </section>
                    <section title="Unauthorised Request: Authorisation Server Discovery" anchor="as_discovery">
	                    <t>
	                        Finally, this document allows the CONNECT message to have an empty Authentication
                            Data field. This is the AS discovery option and the RS responds with the CONNACK
                            reason code '0x87 (Not Authorized)' and includes a User Property (identified by 38 (0x26)) for
                            the AS creation hints as dedined in the Section 5.1.2
                             of <xref target="I-D.ietf-ace-oauth-authz">the ACE framework</xref>.
	                    </t>
                    </section>
                </section>
                <section title="Token Validation" anchor="token_validation">
                    <t>
                        The RS MUST verify the validity of the token.
                        This validation MAY be done locally (e.g., in the case of a self-contained token)
                        or the RS MAY send an introspection request to the AS.
                        If introspection is used, this section follows similar steps to those described in
                         Sections 5.7 of <xref target="I-D.ietf-ace-oauth-authz">the ACE framework</xref>.
                        The communication between AS and RS MUST be confidential,
                        mutually authenticated and integrity protected.
                    </t>
                    <t>
                        The Broker MUST check if the token is
                        active either using 'exp' claim of the token or 'active'
                        parameter of the introspection response. Also, if present in the access token,
                        RS must check that the 'iss' corresponds to AS,
                        the 'aud' field corresponds to RS. It also has to check whether the 'nbf' and the 'iat'
                        claims are present and valid.
		            </t>
                    <t>
                        To authenticate the Client, the RS validates the signature or the MAC, depending on how the PoP protocol is implemented.
                        To authorize the Client, the Broker uses the scope field in the token (or in the introspection result).
                        The scope field contains the publish and subscribe permissions for the Client.
                        If the Will Flag is set,then the Broker MUST check that the token
                        allows the publication of the Will message.
		            </t>
                    <t>
                        Scope strings SHOULD be encoded as a permission, followed by an underscore, followed by a topic filter.
                        Two permissions apply to topics: 'publish' and 'subscribe'.
                        An example scope field may contain multiple such strings, space delimited, e.g., 'publish_topic1 subscribe_topic2/#'.
                        Hence, this access token would give 'publish' permission to the 'topic1', 'subscribe' permission to all the subtopics of 'topic2'.
                    </t>
                </section>
                <section title="The Broker's Response to Client Connection Request">
                   <t>
                        Based on the validation result (obtained either via local inspection or using the /introspection
                        interface of the AS), the Broker MUST send a CONNACK message to the Client.
                        The reason code of the
                        CONNACK is '0x00 (Success)' if the authentication is successful.
	                    In case of an invalid PoP token, the CONNACK reason code
                        is '0x87 (Not Authorized)'.
                    </t>
                    <t>
                        If the RS accepts the connection, it MUST store the token until the end of connection.
                        On Client or RS disconnection, the Client is expected to provide a token again
                        inside the next CONNECT message.
                    </t>
                    <t>
                        If the token is not self-contained and the Broker uses token
                        introspection, it MAY cache the validation result to authorize
                        the subsequent PUBLISH and SUBSCRIBE messages.
                        PUBLISH and SUBSCRIBE messages, which are sent after a connection
                        set-up, do not contain access tokens. If the introspection result
                        is not cached, then the RS needs to introspect the saved token for
                        each request. The Broker SHOULD use a cache time out to introspect
                        tokens regularly.
                    </t>
                </section>
            </section>
            <section title="Authorizing PUBLISH Messages">
                <section title="PUBLISH Messages from the Publisher Client to the Broker">
                    <t>
                        On receiving the PUBLISH message, the Broker MUST use the type of
                        message (i.e., PUBLISH) and the Topic name in the message header to compare against the
                        cached token or its introspection result.
                    </t>
                    <t>
                       If the Client is allowed to publish to the topic,
                        the RS must publish the message to all valid subscribers of the topic. The Broker
                         may also return an acknowledgment
                        message if the QoS level is greater than or equal to 1.
		            </t>
		            <t> In case of an authorization failure, an error MAY be returned to the Client.
                        For this the QoS level of the PUBLISH message, should be set to greater than or equal to 1.
                         This guarantees that RS responds with either a PUBACK or PUBREC packet with reason code
                          '0x87 (Not authorized)'.
	                </t>
		            <t>
		                On receiving a PUBACK with '0x87 (Not authorized)',
                        the Client MAY reauthenticate as described in <xref target="reauthentication"></xref>,
                        and pass a new token following the same PoP methods as described in
                        <xref target="mqtt5_connect_message"></xref>.
		            </t>
                </section>
                <section title="PUBLISH Messages from the Broker to the Subscriber Clients">
		            <t>
		                To forward PUBLISH messages to the subscribing Clients, the Broker identifies all the
                        subscribers that have valid matching topic subscriptions (i.e., the tokens are valid, and
                        token scopes allow a subscription to the particular topic).
                        The Broker sends a PUBLISH message with the Topic name to all the valid
                        subscribers.
                    </t>
                    <t>
                        RS MUST stop forwarding messages to the unauthorized subscribers.
                        For Clients with invalid tokens, there is no way to inform the Client that an
                        authorization error has occurred other than sending a DISCONNECT message.
                        The RS SHOULD send a DISCONNECT message with the reason code '0x87 (Not authorized)'.
                        Note that the server-side DISCONNECT is a new feature of MQTT v5.0 (in MQTT v3.1.1,
                        the server needs to drop the connection).
                    </t>
                </section>
            </section>
            <section title="Authorizing SUBSCRIBE Messages">
                <t>
                    In MQTT, a SUBSCRIBE message is sent from a Client to the Broker to create one or more subscriptions
                    to one or more topics.
                    The SUBSCRIBE message may contain multiple Topic Filters.
                    The Topic Filters may include wildcard characters.
                </t>
                <t>
                    On receiving the SUBSCRIBE message, the Broker MUST use the type of message (i.e.,
                    SUBSCRIBE) and the Topic Filter in the message header to compare
                    against the stored token or introspection result.
                </t>
                <t>
                    As a response to the SUBSCRIBE message, the Broker issues a SUBACK message. For each Topic Filter,
                    the SUBACK packet includes a return code matching the QoS level
                    for the corresponding Topic Filter. In the case of failure, the return code is 0x87,
                     indicating that the Client is 'Not authorized'. A reason code is returned for each Topic Filter.
		            Therefore, the Client may receive success codes for a subset of its Topic Filters while being
		            unauthorized for the rest.
                </t>
            </section>
            <section anchor="reauthentication" title="Token Expiration and Reauthentication">
                <t>
                    The Broker MUST check for token expiration whenever a CONNECT, PUBLISH or SUBSCRIBE message is received
                    or sent. The Broker SHOULD check for token expiration on receiving a PINGREQUEST message.
                    The Broker MAY also check for token expiration periodically e.g., every hour. This may allow
		            for early detection of a token expiry.
		        </t>
		        <t>
                    The token expiration is checked by checking the 'exp' claim of a JWT or introspection response, or via performing an
                    introspection request with the Authorization server as described in Section 5.7 of <xref
                        target="I-D.ietf-ace-oauth-authz">the ACE framework</xref>.
                    Token expirations may trigger the RS to send PUBACK, SUBACK and DISCONNECT messages with return code
                     set to 'Not authorised'.
		            As a response, the Client MAY re-authenticate
                    by sending an AUTH packet with a Reason Code of 0x19 (Re-authentication)
                </t>
		        <t>
		            To re-authenticate, the Client sends an AUTH packet with reason code '0x19 (Re-authentication)'.
                    The Client MUST
		            set the authentication method as 'ace' and transport the new token in the Authentication Data.
		            The Client and the RS go through the same steps for proof of possession validation
                     as described in <xref target="connect_v5"></xref>.
		            If the re-authentication fails, the server
		            MUST send a DISCONNECT with the reason code '0x87 (Not Authorized)'.
		            The Clients can also proactively update their tokens before
                     they receive a message with 'Not authorized' return code.
		         </t>
            </section>
            <section title="Handling Disconnections and Retained Messages" anchor="disconnections">
		        <t>
                    In the case of a Client DISCONNECT, due to the Clean Session flag, the Broker
                    deletes all session state but MUST keep the retained messages.
                    By setting a RETAIN flag in a PUBLISH message,
                    the publisher indicates to the Broker that it should store the most
                    recent message for the associated topic.  Hence, the new subscribers can receive
                    the last sent message from the publisher of that particular topic without waiting
                     for the next PUBLISH message.
                    The Broker MUST continue publishing
                    the retained messages as long as the associated tokens are valid.
                </t>
                <t>
                    In case of disconnections due to network errors or server disconnection due to a protocol error
                    (which includes authorization errors), the Will message must be sent if the Client supplied
                    a Will in the CONNECT message.  The Client's token scopes MUST include the Will Topic.
                    The Will message MUST be published to the Will Topic when the network connection is closed regardless of whether the corresponding
		            token has expired. In the case of a server-side DISCONNECT, the server returns the '0x87 Not Authorized' return code
                   to the Client.
                </t>
            </section>
        </section>
	<section anchor="MQTTv311" title="Reduced Protocol Interactions for MQTT v3.1.1">
        <t>
        This section describes a reduced set of protocol interactions for the MQTT v3.1.1 Client.
        </t>
	    <section anchor="token_311" title="Token Transport">
	        <t>
                To transport the token to the Broker, the Clients use the username and password fields of the CONNECT
                control message after the TLS handshake.
                <xref target="mqtt_connect_message"></xref> shows the structure of the MQTT CONNECT message.
            </t>
          <figure align="center" anchor="mqtt_connect_message" title="MQTT CONNECT control message. (CPT=Control Packet Type, Rsvd=Reserved, len.=length, Proto.=Protocol)">
         <artwork align="left"><![CDATA[
       0            8            16            24            32
       +------------------------------------------------------+
       |CPT=1 | Rsvd.|Remaining len.| Protocol  name len. = 4 |
       +------------------------------------------------------+
       |                      'M' 'Q' 'T' 'T'                 |
       +------------------------------------------------------+
       | Proto.level=4|Connect flags|          Keep alive     |
       +------------------------------------------------------+
       | Payload                                              |
       |     Client Identifier                                |
       |     Username as access token (UTF-8)     	          |
       |     Password length (2 Bytes)                        |
       |     Password data as signature/MAC (binary)          |
       +------------------------------------------------------+
        ]]></artwork>
          </figure>
	  <t>
            <xref target="mqtt_connect_flags"></xref> shows how the MQTT connect flags MUST be set to initiate
             a connection with the Broker.
          </t>
        <figure align="center" anchor="mqtt_connect_flags" title="MQTT CONNECT flags. (Rsvd=Reserved)">
         <artwork align="left"><![CDATA[
+-----------------------------------------------------------+
|User name|Pass.|Will retain|Will QoS|Will Flag|Clean| Rsvd.|
| flag    |flag |           |        |         |     |      |
+-----------------------------------------------------------+
| 1       | 1   |    X      |   X X  |   X     |  1   |  0  |
+-----------------------------------------------------------+
         ]]></artwork>
         </figure>
                    <t>
                        The Clean Session Flag MUST be set to 1. The Client may set the Will Flag
                         as desired (marked as 'X' in <xref
                            target="mqtt_connect_flags"></xref>).
                        Username and Password flags MUST be set to 1 to  ensure that the Payload of the
                        CONNECT message includes both Username and Password fields.
                    </t>
                    <t>
                        The CONNECT message defaults to ACE for authentication and authorization.
                        The Username field MUST be set to the access token.
                        The Password field MUST be set to the keyed message digest (MAC)
                         or signature associated with the access token
			            for proof-of-possession.
                        The Client MUST apply the PoP key to the payload as described in <xref target="pop_payload"></xref>.
                    </t>
                    <t>
                        In MQTT v3.1.1, the MQTT Username as a UTF-8 encoded string (i.e.,
                        is prefixed by a  2-byte length field followed by UTF-8 encoded character data) and may be
			            up to 65535 bytes.
                         Therefore, an access token that is not a valid UTF-8 MUST be Base64
                          <xref target="RFC4648"></xref> encoded.
                        (The MQTT Password allows binary data up to 65535 bytes.)
                    </t>
		  </section>
		  <section anchor="errors_311" title="Handling Authorization Errors">
		    <t>
                Handling errors are more primitive in MQTT v3.1.1 due to not having appropriate error fields,
                error codes, and server-side DISCONNECTS. In the following, we
		        list how errors are handled without such protocol support.
		    </t>
		    <t>
		    <list style="symbols">
		    <t>
                CONNECT without a token: It is not possible to support AS discovery via sending a tokenless CONNECT
                 message to the Broker. This is because a CONNACK packet in MQTT v3.1.1
                  does not include a means to provide additional information to the Client.
			    Therefore, AS discovery needs to take place out-of-band. CONNECT attempt MUSY fail.
		      </t>
		      <t>
                Client-RS PUBLISH authorization failure: In case of a failure,
                  it is not possible to return an error in MQTT v3.1.1.
		       Acknowledgement messages only indicate success. In the case of an authorization error,
                the Broker SHOULD disconnect the Client.
		       Otherwise, it MUST ignore the PUBLISH message. Also, DISCONNECT messages are only sent
                from a Client to the Broker. So, server disconnection needs to take place below the application layer.
		      </t>
		      <t> SUBSCRIBE authorization failure:  In the  SUBACK packet, the return code must be 0x80 indicating
               'Failure' for the unauthorized topic(s). Note that, in both MQTT versions, a reason code is
                returned for each Topic Filter.
		      </t>
		      <t>RS-Client PUBLISH authorization failure:  When RS is forwarding PUBLISH messages to the subscribed Clients,
		      it may discover that some of the subscribers are no more authorized due to expired tokens.
               These token expirations SHOULD lead to disconnecting the Client, rather than silently dropping messages.
		      </t>
		    </list>
		    </t>
		  </section>
	</section>

	<!-- This PI places the pagebreak correctly (before the section title) in the text output. -->

        <!--<?rfc needLines="8" ?>-->

        <!-- Possibly a 'Acknowledgements'/ 'Contributors' section ... -->
        <section anchor="IANA" title="IANA Considerations">
          <t>The following registrations are done for the ACE OAuth Profile Registry following the procedure specified in
	        <xref target="I-D.ietf-ace-oauth-authz"></xref>.
	    </t>
	  <t>Note to the RFC editor: Please replace all occurrences of "[RFC-XXXX]" with the RFC number of this specification
	  and delete this paragraph.
	  </t>
	  <t>Profile name: mqtt_tls</t>
	  <t>Profile description: Profile for delegating Client authentication and authorization using MQTT as the application protocol
	  and TLS For transport layer security.</t>
	  <t>Profile ID: </t>
	  <t>Change controller: IESG </t>
	  <t>Reference: [RFC-XXXX]</t>
        </section>

        <section anchor="Security" title="Security Considerations">

	  <t> This document specifies a profile for the Authentication and Authorization for Constrained Environments (ACE) framework
	  <xref target="I-D.ietf-ace-oauth-authz"></xref>. Therefore, the security considerations outlined
	  in <xref target="I-D.ietf-ace-oauth-authz"></xref> apply to this work.
	  </t>
	  <t> In addition, the security considerations outlined in <xref target="MQTT-OASIS-Standard-v5">MQTT v5.0 - the OASIS Standard</xref>
	  and <xref target="MQTT-OASIS-Standard">MQTT v3.1.1 - the OASIS Standard</xref>
	   apply.  Mainly, this document provides an authorization solution for MQTT,
	   the responsibility of which is left to the specific implementation in  MQTT v5.0 standard.
	 In the following, we comment on a few relevant issues based on the current MQTT specifications.
	  </t>

	  <t>In this document, RS uses the PoP access token to authenticate the Client.
        If the Client is able, TLS certificates sent from the Client can be used by the RS to authenticate the Client.
	    The Client may authenticate the RS either using a server cerficate or the RPK method. In the case of RPK, client needs to use
        this raw public key in the TLS handshake together
        with an out-of-band validation technique (see <xref target="RFC7250"></xref>
        for details).
	  </t>

	  <t>To authorize a Client's publish and subscribe requests in an ongoing session, the RS caches the access token after accepting the
	  connection from the Client. However, if some permissions are revoked in the meantime,
	  the RS may still grant publish/subscribe to revoked topics.
      If the RS caches the token introspection responses, then the RS should use a reasonable cache timeout
       to introspect tokens regularly.
	  When permissions change dynamically, it is expected that AS also
       follows a reasonable expiration strategy for the access tokens.
	  </t>
	  <t> The RS may monitor Client behaviour to detect potential security problems, especially those affecting availability.
	  These include repeated token transfer attempts to the public "authz-info" topic, repeated connection attempts,
	  abnormal terminations, and Clients that connect but do not send any data.
	  If the RS supports the public "authz-info" topic, described in <xref target="app-authzinfo"></xref>,
	  then this may be vulnerable to a DDoS attack, where many Clients use the "authz-info" public topic
       to transport fictitious tokens,
	  which RS may need to store indefinitely.</t>
        </section>

        <section anchor="Privacy" title="Privacy Considerations">
            <t>The privacy considerations outlined in <xref target="I-D.ietf-ace-oauth-authz"></xref> apply to this work.
            </t>
	        <t>In MQTT, the RS is a central trusted party and may forward potentially sensitive information
	        between Clients. Clients may choose to encrypt the payload of their messages.
	        However, this would not provide privacy for other properties of the message such as Topic Name.
	        </t>
        </section>
    </middle>


    <!--  *****BACK MATTER ***** -->

    <back>
        <!-- References split into informative and normative -->

        <!-- There are 2 ways to insert reference entries from the citation libraries:
         1. define an ENTITY at the top, and use "ampersand character"RFC2629; here (as shown)
         2. simply use a PI "less than character"?rfc include="reference.RFC.2119.xml"?> here
            (for I-Ds: include="reference.I-D.narten-iana-considerations-rfc2434bis.xml")

         Both are cited textually in the same manner: by using xref elements.
         If you use the PI option, xml2rfc will, by default, try to find included files in the same
         directory as the including file. You can also define the XML_LIBRARY environment variable
         with a value containing a set of directories to search.  These can be either in the local
         filing system or remote ones accessed by http (http://domain/dir/... ).-->

        <references title="Normative References">
            <!--?rfc include="http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml"?-->
            &RFC2119;
            &RFC4648;
	    &RFC8174;
        &RFC7250;
            <reference anchor="MQTT-OASIS-Standard"
                       target="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/mqtt-v3.1.1.html">
                <front>
                    <title>
                        OASIS Standard MQTT Version 3.1.1 Plus Errata 01
                    </title>
                    <author initials="A." surname="Banks" role="editor">
                        <organization>IBM</organization>
                    </author>
                    <author initials="R." surname="Gupta" role="editor">
                        <organization>IBM</organization>
                    </author>
                    <date year="2015"/>
                </front>
            </reference>

	    <reference anchor="MQTT-OASIS-Standard-v5"
		       target="http://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html">
	       <front>
		 <title>
		   OASIS Standard MQTT Version 5.0
		 </title>
		 <author initials="A." surname="Banks" role="editor">
		   <organization>IBM</organization>
		 </author>
		 <author initials="E." surname="Briggs" role="editor">
		   <organization>Microsoft</organization>
		 </author>
		 <author initials="K." surname="Borgendale" role="editor">
		   <organization>IBM</organization>
		 </author>
		 <author initials="R." surname="Gupta" role="editor">
                   <organization>IBM</organization>
                 </author>
		 <date year="2017"/>
 	       </front>
	    </reference>

            <?rfc include="reference.I-D.ietf-ace-oauth-authz.xml"?>

            <?rfc include="reference.I-D.gerdes-ace-dtls-authorize.xml"?>

        </references>

        <references title="Informative References">
            <!-- Here we use entities that we defined at the beginning. -->
            <!-- A reference written by by an organization not a person. -->
	    <?rfc include="reference.I-D.ietf-ace-cwt-proof-of-possession.xml"?>
            &RFC4949;
            &RFC6749;
	    &RFC7800;
	    <reference anchor="fremantle14" target="http://dx.doi.org/10.1109/SIoT.2014.8">
		<front>
			<title>
				Federated Identity and Access Management for the Internet of Things
			</title>
			<author initials="P." surname="Fremantle"></author>
			<author initials="B." surname="Aziz"></author>
			<author initials="J." surname="Kopecky"></author>
			<author initials="P." surname="Scott"></author>
			<date month="September" year="2014"></date>
		</front>
		<seriesInfo name="research" value="International Workshop on Secure Internet of Things"></seriesInfo>
	    </reference>
        </references>

        <section anchor="app-profile-requirements" title="Checklist for profile requirements">
            <t>
                <list style="symbols">
                  <t>AS discovery: AS discovery is possible with the MQTT v5.0 described in <xref target="connect_v5"></xref>.
                    </t>
                    <t>The communication protocol between the Client and RS: MQTT</t>
                    <t>The security protocol between the Client and RS: TLS</t>
                    <t>Client and RS mutual authentication: RS provides a server certificate or RPK during TLS handshake. Client
                        transports token and MAC via the MQTT
                        CONNECT message.
                    </t>
                    <t>Content format: For the HTTPS interactions with AS, "application/ace+json".
                        The MQTT payloads may be formatted in JSON.
                    </t>
                    <t>PoP protocols: Either symmetric or asymmetric keys can be supported.</t>
                    <t>Unique profile identifier: mqtt_tls</t>
                    <t>Token introspection: RS uses HTTPS /introspect interface of AS.</t>
                    <t>Token request: CAS uses HTTPS /token interface of AS.</t>
                    <t>/authz-info endpoint: It MAY be supported using the method described in <xref
                            target="app-authzinfo"></xref>, but is
                        not protected.
                    </t>
                    <t>Token transport: In MQTT CONNECT message for both versions of MQTT.
                      AUTH extensions also used for authentication and re-authentication for
		            MQTT v5.0 as described in <xref target="connect_v5"></xref>.</t>
                </list>
            </t>
        </section>

        <section anchor="app-authzinfo" title="The Authorization Information Endpoint">
          <t>The main document described a method for transporting tokens inside MQTT CONNECT messages.
                In this section, we describe an alternative method to transport an access token.
            </t>
            <t>
                The method consists of the MQTT Broker accepting PUBLISH messages to a public "authz-info" topic. A Client using this method
                MUST first
                connect to the Broker, and publish the access token using the "authz-info" topic. The Broker
                must verify the validity of the token (i.e., through local validation or introspection).
                After publishing the token, the Client disconnects from the Broker and is expected to try reconnecting over TLS.
            </t>
            <t> In MQTT v5.0, the Broker can return 'Not authorized' error to a PUBLISH request for QoS greater or equal to 1.
	        In MQTT v3.1.1, after the Client published to the "authz-info" topic, it is not possible for the Broker to communicate
                the result of the token verification. In any case, any token authorization failure affect the subsequent TLS handshake, which can prompt the Client to
                obtain a valid token.
            </t>
        </section>

    <!-- Change Log
     -->

	<section anchor="document_updates" title="Document Updates">
    <t>
        Version 00 to 01:
        <list style="symbols">
            <t> Present the MQTTv5 as the RECOMMENDED version, and MQTT v3.1.1 for backward compatibility. </t>
            <t> Clarified Will message. </t>
            <t> Improved consistency in the use of terminology, and upper/lower case. </t>
            <t> Defined Broker and MQTTS. </t>
            <t> Clarified HTTPS use for C-AS and RS-AS communication. Removed reference to actors document, and clarified the use of client authorization server.</t>
            <t> Clarified the Connect message payload and Client Identifier. </t>
            <t> Presented different methods for passing the token, and PoP. </t>
            <t> Added new figures for AUTH methods, updated CONNECT message figure. </t>
        </list>
    </t>
	</section>


	<section anchor="Acknowledgements" title="Acknowledgements" numbered="no" toc="default">
		<t>
                The authors would like to thank Ludwig Seitz for his review and his input on the authorization information endpoint,
		 presented in the appendix.
              </t>
	</section>
    </back>

</rfc>

